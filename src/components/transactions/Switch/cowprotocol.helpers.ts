import { API_ETH_MOCK_ADDRESS } from '@aave/contract-helpers';
import {
  BuyTokenDestination,
  MAX_VALID_TO_EPOCH,
  OrderBookApi,
  OrderKind,
  OrderParameters,
  OrderStatus,
  SellTokenSource,
  SupportedChainId,
  TradingSdk,
  UnsignedOrder,
} from '@cowprotocol/cow-sdk';
import { JsonRpcProvider } from '@ethersproject/providers';
import { BigNumber, ethers, PopulatedTransaction } from 'ethers';
import { getErrorTextFromError, TxAction, TxErrorType } from 'src/ui-config/errorMapping';

import { isChainIdSupportedByCoWProtocol, WrappedNativeTokens } from './switch.constants';

// As generated by https://explorer.cow.fi/appdata?tab=encode
export const APP_CODE = 'AaveV3';
export const APP_DATA_STRING =
  '{"appCode":"AaveV3","metadata":{"hooks":{"version":"0.1.0"}},"version":"1.3.0"}';
export const APP_DATA_HASH = '0xec632b4acad3a229df259d7e20dbe1046eb56c9d31cc304ea6186c746a6a81e3';
export const COW_PROTOCOL_ETH_FLOW_ADDRESS = '0xbA3cB449bD2B4ADddBc894D8697F5170800EAdeC';
const COW_CREATE_ORDER_ABI =
  'function createOrder((address,address,uint256,uint256,bytes32,uint256,uint32,bool,int64)) returns (bytes32)';

export type CowProtocolActionParams = {
  quote: OrderParameters;
  provider: JsonRpcProvider;
  chainId: number;
  user: string;
  setError: (error: TxErrorType) => void;
  amount: string;
  destAmount: string;
  tokenDest: string;
  tokenSrc: string;
  tokenSrcDecimals: number;
  tokenDestDecimals: number;
};

export const sendOrder = async ({
  provider,
  tokenDest,
  chainId,
  user,
  setError,
  amount,
  tokenSrc,
  tokenSrcDecimals,
  tokenDestDecimals,
  destAmount,
}: CowProtocolActionParams) => {
  const signer = provider?.getSigner();
  const tradingSdk = new TradingSdk({ chainId, signer, appCode: APP_CODE });

  if (!isChainIdSupportedByCoWProtocol(chainId)) {
    setError(
      getErrorTextFromError(
        new Error('Chain not supported by CowProtocol'),
        TxAction.MAIN_ACTION,
        true
      )
    );
    return;
  }

  if (!signer) {
    setError(
      getErrorTextFromError(new Error('No signer found in provider'), TxAction.MAIN_ACTION, true)
    );
    return;
  }

  try {
    return tradingSdk
      .postLimitOrder({
        owner: user as `0x${string}`,
        sellAmount: amount,
        buyAmount: destAmount,
        kind: OrderKind.SELL,
        sellToken: tokenSrc,
        buyToken: tokenDest,
        sellTokenDecimals: tokenSrcDecimals,
        buyTokenDecimals: tokenDestDecimals,
      })
      .then((orderResult) => orderResult.orderId)
      .catch((e) => {
        console.error(e);
        setError(getErrorTextFromError(e, TxAction.MAIN_ACTION, true));
      });
  } catch (e) {
    console.error(e);
    setError(getErrorTextFromError(e, TxAction.MAIN_ACTION, true));
  }
};

export const getOrderStatus = async (orderId: string, chainId: number) => {
  const orderBookApi = new OrderBookApi({ chainId: chainId });
  const status = await orderBookApi.getOrderCompetitionStatus(orderId, {
    chainId,
  });
  return status.type;
};

export const getOrder = async (orderId: string, chainId: number) => {
  const orderBookApi = new OrderBookApi({ chainId });
  const order = await orderBookApi.getOrder(orderId, {
    chainId,
  });
  return order;
};

export const getOrders = async (chainId: number, account: string) => {
  const orderBookApi = new OrderBookApi({ chainId });
  const orders = await orderBookApi.getOrders({
    owner: account,
  });

  return orders;
};

export const isOrderLoading = (status: OrderStatus) => {
  return status === OrderStatus.OPEN;
};

export const isOrderFilled = (status: OrderStatus) => {
  return status === OrderStatus.FULFILLED;
};

export const isOrderCancelled = (status: OrderStatus) => {
  return status === OrderStatus.CANCELLED || status === OrderStatus.EXPIRED;
};

export const isNativeToken = (token: string) => {
  return token.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase();
};

export const getUnsignerOrder = (
  sellAmount: string,
  buyAmount: string,
  dstToken: string,
  user: string,
  chainId: number
): UnsignedOrder => {
  return {
    buyToken: dstToken,
    receiver: user,
    sellAmount,
    buyAmount,
    appData: APP_DATA_HASH,
    feeAmount: '0',
    validTo: MAX_VALID_TO_EPOCH,
    partiallyFillable: false,
    kind: OrderKind.SELL,
    sellToken: WrappedNativeTokens[chainId as SupportedChainId].toLowerCase(),
    buyTokenBalance: BuyTokenDestination.ERC20,
    sellTokenBalance: SellTokenSource.ERC20,
  };
};

export const populateEthFlowTx = (
  sellAmount: string,
  buyAmount: string,
  dstToken: string,
  user: string,
  validTo: number,
  quoteId?: number
): PopulatedTransaction => {
  const orderData = {
    buyToken: dstToken,
    receiver: user,
    sellAmount,
    buyAmount,
    appData: APP_DATA_HASH,
    feeAmount: '0',
    validTo,
    partiallyFillable: false,
    quoteId: quoteId || 0,
  };

  const value = BigNumber.from(sellAmount);

  // Create the contract interface
  const iface = new ethers.utils.Interface([COW_CREATE_ORDER_ABI]);

  // Encode the function call
  const data = iface.encodeFunctionData('createOrder', [
    [
      orderData.buyToken,
      orderData.receiver,
      orderData.sellAmount,
      orderData.buyAmount,
      orderData.appData,
      orderData.feeAmount,
      orderData.validTo,
      orderData.partiallyFillable,
      orderData.quoteId,
    ],
  ]);

  return {
    to: COW_PROTOCOL_ETH_FLOW_ADDRESS,
    value,
    data,
  };
};

export const getRecommendedSlippage = (srcUSD: string) => {
  try {
    if (Number(srcUSD) <= 0) {
      return Number(0.5);
    }

    if (Number(srcUSD) <= 1) {
      return Number(5.0);
    } else if (Number(srcUSD) <= 5) {
      return Number(2.5);
    } else if (Number(srcUSD) <= 10) {
      return Number(1.5);
    } else {
      return Number(0.5);
    }
  } catch (e) {
    return Number(0.5);
  }
};
