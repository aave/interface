import { ChainId } from '@aave/contract-helpers';
import { Trans } from '@lingui/macro';
import { Skeleton, Stack, Typography } from '@mui/material';
import { BigNumber } from 'bignumber.js';
import { parseUnits } from 'ethers/lib/utils';
import React, { useRef, useState } from 'react';
import { FormattedNumber } from 'src/components/primitives/FormattedNumber';
import { Row } from 'src/components/primitives/Row';
import { TokenIcon } from 'src/components/primitives/TokenIcon';
import { AssetInput } from 'src/components/transactions/AssetInput';
import { TxErrorView } from 'src/components/transactions/FlowCommons/Error';
import { GasEstimationError } from 'src/components/transactions/FlowCommons/GasEstimationError';
import { TxSuccessView } from 'src/components/transactions/FlowCommons/Success';
import {
  DetailsHFLine,
  DetailsUnwrapSwitch,
  TxModalDetails,
} from 'src/components/transactions/FlowCommons/TxModalDetails';
import { GasStation } from 'src/components/transactions/GasStation/GasStation';
import { ExtendedFormattedUser } from 'src/hooks/pool/useExtendedUserSummaryAndIncentives';
import { FormattedReservesAndIncentives } from 'src/hooks/pool/usePoolFormattedReserves';
import { MergedStakeData } from 'src/hooks/stake/useUmbrellaSummary';
import { useModalContext } from 'src/hooks/useModal';
import { useWeb3Context } from 'src/libs/hooks/useWeb3Context';
import { useRootStore } from 'src/store/root';
import { calculateHFAfterSupply } from 'src/utils/hfUtils';
import { useShallow } from 'zustand/shallow';

import { usePreviewRedeem } from './hooks/usePreviewRedeem';
import { UnStakeActions } from './UnstakeModalActions';
import { normalizeBN } from '@aave/math-utils';

export enum RedeemType {
  NORMAL,
  ATOKEN,
  NATIVE,
}

export const UnStakeModalContent = ({
  stakeData,
  poolReserve,
  user,
}: {
  stakeData: MergedStakeData;
  poolReserve: FormattedReservesAndIncentives;
  user: ExtendedFormattedUser;
}) => {
  const { chainId: connectedChainId } = useWeb3Context();
  const { gasLimit, mainTxState: txState, txError } = useModalContext();
  const [redeemType, setRedeemType] = useState(RedeemType.NORMAL);
  const [currentChainId, currentNetworkConfig] = useRootStore(
    useShallow((store) => [store.currentChainId, store.currentNetworkConfig])
  );

  const [amount, setAmount] = useState('');
  const amountRef = useRef<string>();

  const { data: redeemedAmount, isLoading } = usePreviewRedeem(
    parseUnits(amount || '0', stakeData.decimals).toString(),
    stakeData.decimals,
    stakeData.underlyingIsStataToken ? stakeData.underlyingTokenAddress : '',
    currentChainId
  );

  const redeemableAmountBN = BigNumber.min(
    stakeData?.balances.stakeTokenRedeemableAmount || '0',
    stakeData?.cooldownData.cooldownAmount || '0'
  );

  const redeemableAmount = normalizeBN(redeemableAmountBN.toString(), stakeData.decimals).toString();

  const isMaxSelected = amount === '-1';
  const amountToRedeem = isMaxSelected ? redeemableAmount : amount;

  const handleChange = (value: string) => {
    const maxSelected = value === '-1';
    const amount = maxSelected ? redeemableAmount : value;
    amountRef.current = amount;
    setAmount(amount);
  };

  const amountToRedeemUsd = new BigNumber(amountToRedeem || '0')
    .multipliedBy(stakeData.price)
    .shiftedBy(-8);

  // could be different in the case of waTokens, since the exchange rate will take into account
  // the yield generated by the aToken
  const redeemedAmountUsd = new BigNumber(redeemedAmount || '0').multipliedBy(
    poolReserve.priceInUSD
  );

  // error handler
  // let blockingError: ErrorType | undefined = undefined;
  // if (valueToBigNumber(amountToRedeem).gt(redeemableAmount)) {
  //   blockingError = ErrorType.NOT_ENOUGH_BALANCE;
  // }

  // const handleBlocked = () => {
  //   switch (blockingError) {
  //     case ErrorType.NOT_ENOUGH_BALANCE:
  //       return <Trans>Not enough staked balance</Trans>;
  //     default:
  //       return null;
  //   }
  // };

  const setRedeemATokens = (value: boolean) => {
    setRedeemType(value ? RedeemType.ATOKEN : RedeemType.NORMAL);
  };

  const symbolFormatted = stakeData.underlyingIsStataToken
    ? stakeData.stataTokenData.assetSymbol
    : stakeData.underlyingTokenSymbol;

  const isWrongNetwork = currentChainId !== connectedChainId;

  let hfAfterRedeem = '-1';
  if (user && stakeData.underlyingIsStataToken && redeemType === RedeemType.ATOKEN) {
    const amountInEth = new BigNumber(amount).multipliedBy(
      poolReserve.formattedPriceInMarketReferenceCurrency
    );

    hfAfterRedeem = calculateHFAfterSupply(user, poolReserve, amountInEth).toString();
  }

  if (txError && txError.blocking) {
    return <TxErrorView txError={txError} />;
  }

  if (txState.success)
    return (
      <TxSuccessView
        action={<Trans>Unstaked</Trans>}
        amount={amountRef.current}
        symbol={symbolFormatted}
      />
    );

  return (
    <>
      <AssetInput
        value={amountToRedeem}
        onChange={handleChange}
        usdValue={amountToRedeemUsd.toString()}
        symbol={symbolFormatted}
        assets={[
          {
            balance: redeemableAmount,
            symbol: stakeData.iconSymbol,
          },
        ]}
        isMaxSelected={isMaxSelected}
        maxValue={redeemableAmount}
        balanceText={<Trans>Stake balance</Trans>}
      />

      {stakeData.underlyingIsStataToken && (
        <DetailsUnwrapSwitch
          unwrapped={redeemType === RedeemType.ATOKEN}
          setUnWrapped={setRedeemATokens}
          label={
            <Typography>
              <Trans>Redeem as aToken</Trans>
            </Typography>
          }
        />
      )}

      {stakeData.underlyingIsStataToken ? (
        <TxModalDetails gasLimit={gasLimit} chainId={currentChainId}>
          <Row
            caption={<Trans>Amount received</Trans>}
            captionVariant="description"
            mb={2}
            align="flex-start"
          >
            <Stack direction="column" alignItems="flex-end" justifyContent="center">
              {isLoading ? (
                <Skeleton
                  variant="rectangular"
                  height={20}
                  width={100}
                  sx={{ borderRadius: '4px' }}
                />
              ) : (
                <>
                  <Stack direction="row" alignItems="center">
                    <TokenIcon
                      aToken={redeemType === RedeemType.ATOKEN}
                      symbol={
                        redeemType === RedeemType.NATIVE
                          ? currentNetworkConfig.baseAssetSymbol
                          : stakeData.stataTokenData.assetSymbol
                      }
                      sx={{ mr: 2, ml: 4, fontSize: '20px' }}
                    />
                    <FormattedNumber value={redeemedAmount || '0'} variant="secondary14" compact />
                  </Stack>
                  <FormattedNumber
                    value={redeemedAmountUsd.toString()}
                    variant="helperText"
                    compact
                    symbol="USD"
                    symbolsColor="text.secondary"
                    color="text.secondary"
                  />
                </>
              )}
            </Stack>
          </Row>
          {redeemType === RedeemType.ATOKEN && (
            <DetailsHFLine
              healthFactor={user?.healthFactor || '-1'}
              futureHealthFactor={hfAfterRedeem}
              visibleHfChange={!!redeemedAmount}
              loading={isLoading}
            />
          )}
        </TxModalDetails>
      ) : (
        <GasStation gasLimit={parseUnits(gasLimit || '0', 'wei')} chainId={ChainId.mainnet} />
      )}

      {/* {blockingError !== undefined && (
        <Typography variant="helperText" color="red">
          {handleBlocked()}
        </Typography>
      )} */}

      {txError && <GasEstimationError txError={txError} />}

      <UnStakeActions
        sx={{ mt: '48px' }}
        amountToUnStake={amountToRedeem || '0'}
        isWrongNetwork={isWrongNetwork}
        symbol={symbolFormatted}
        blocked={false}
        stakeData={stakeData}
        redeemType={redeemType}
      />
    </>
  );
};
